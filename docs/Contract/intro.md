## Smart contract introduction

At its core, a blockchain platform can be viewed as a distributed multi-tenant database which holds the state of all the smart contracts deployed on it. After deployment, each smart contract will have a unique address. The address is used to scope the state and as the identifier for state queries and updates. The methods defined in smart contract code provides the permission checks and logics for queries and updates.

In aelf, a smart contract essentially has three parts: the interface, the state, and the business logics.

1. The interface

   aelf supports smart contracts coded in multiple languages. Protobuf format is adopted as the cross-language definition of the contract.
2. The state

   The language specific SDKs provide some prototypes for the state of different types.
3. The logics

   aelf provides protobuf plugins to generate the smart contract skeleton from the contract's proto definition. Developers just need to fill the logics for each method.

### Example

In this section, we give an example of a smart contract. The original version of this contract is from solidity and we ported to aelf, so that for those who is familiar with solidity may make better sense on how smart contracts on aelf are similar to those on solidity and what are the nuances.

1. The interface
```protobuf
syntax = "proto3";

package ballot;

import "aelf_options.proto";
import "common.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

option csharp_namespace = "Ballot";

service Ballot {
    option (aelf.csharp_state) = "BallotState";
    // Actions
    rpc Initialize (InitializeInput) returns (google.protobuf.Empty) {
    }
    rpc GiveRightToVote(Address) returns (google.protobuf.Empty) {
    }
    rpc Delegate(Address) returns (google.protobuf.Empty) {
    }
    rpc Vote(google.protobuf.UInt32Value) returns (google.protobuf.Empty) {
    }
    // Views
    rpc GetWinningProposal(google.protobuf.Empty) returns(Proposal){
        option (aelf.is_view) = true;
    }
    rpc GetChainPerson(google.protobuf.Empty) returns(Address){
        option (aelf.is_view) = true;
    }
}

message InitializeInput {
    repeated string proposal_names = 1;
}

message Voter {
    uint32 weight = 1;
    bool voted = 2;
    Address delegate = 3;
    uint32 vote = 4;
}

message Proposal {
    string name = 1;
    uint32 vote_count = 2;
}

```

This proto file mainly defines one service and a few messages. The service provides the declarations of the methods (preceded with `rpc` keyword) served by the contract. The messages define the structured data needed to exchange the data from and to the contract.

2. The state

   In contrast to solidity idea of treating a smart contract as an object in OOP concepts, aelf treats smart contract more like a service which is essentially no different from a web service or an rpc service. Hence, the state in aelf's contract is defined as a separate class instead of as embedded fields in the contract class. During runtime, the defined state is injected into the context. Below is an example of the definition of the state of a C# contract.
```csharp
using AElf.Common;
using AElf.Sdk.CSharp.State;

namespace Ballot
{
    public class BallotState : ContractState
    {
        public MappedState<Address, Voter> Voters { get; set; }
        public MappedState<uint, Proposal> Proposals { get; set; }
        public UInt32State ProposalCount { get; set; }
        public SingletonState<Address> ChairPerson { get; set; }
    }
}
```

1. Contract skeleton

   Below is the contract skeleton generated by aelf's protobuf plugin for contract. Besides the method information and the marshallers, there is an abstract class `BallotBase` which holds all the defined methods. Developers just need to inherit this base class and fill in the logics for the queries or state updates.
```csharp
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: ballot.proto
// </auto-generated>
#pragma warning disable 0414, 1591
#region Designer generated code

using aelf = global::AElf.Types.CSharp;

namespace Ballot {

  #region Events
  #endregion
  public static partial class BallotContainer
  {
    static readonly string __ServiceName = "ballot.Ballot";

    #region Marshallers
    static readonly aelf::Marshaller<global::Ballot.InitializeInput> __Marshaller_ballot_InitializeInput = aelf::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Ballot.InitializeInput.Parser.ParseFrom);
    static readonly aelf::Marshaller<global::Google.Protobuf.WellKnownTypes.Empty> __Marshaller_google_protobuf_Empty = aelf::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Google.Protobuf.WellKnownTypes.Empty.Parser.ParseFrom);
    static readonly aelf::Marshaller<global::AElf.Common.Address> __Marshaller_Address = aelf::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::AElf.Common.Address.Parser.ParseFrom);
    static readonly aelf::Marshaller<global::Google.Protobuf.WellKnownTypes.UInt32Value> __Marshaller_google_protobuf_UInt32Value = aelf::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Google.Protobuf.WellKnownTypes.UInt32Value.Parser.ParseFrom);
    static readonly aelf::Marshaller<global::Ballot.Proposal> __Marshaller_ballot_Proposal = aelf::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Ballot.Proposal.Parser.ParseFrom);
    #endregion

    #region Methods
    static readonly aelf::Method<global::Ballot.InitializeInput, global::Google.Protobuf.WellKnownTypes.Empty> __Method_Initialize = new aelf::Method<global::Ballot.InitializeInput, global::Google.Protobuf.WellKnownTypes.Empty>(
        aelf::MethodType.Action,
        __ServiceName,
        "Initialize",
        __Marshaller_ballot_InitializeInput,
        __Marshaller_google_protobuf_Empty);

    static readonly aelf::Method<global::AElf.Common.Address, global::Google.Protobuf.WellKnownTypes.Empty> __Method_GiveRightToVote = new aelf::Method<global::AElf.Common.Address, global::Google.Protobuf.WellKnownTypes.Empty>(
        aelf::MethodType.Action,
        __ServiceName,
        "GiveRightToVote",
        __Marshaller_Address,
        __Marshaller_google_protobuf_Empty);

    static readonly aelf::Method<global::AElf.Common.Address, global::Google.Protobuf.WellKnownTypes.Empty> __Method_Delegate = new aelf::Method<global::AElf.Common.Address, global::Google.Protobuf.WellKnownTypes.Empty>(
        aelf::MethodType.Action,
        __ServiceName,
        "Delegate",
        __Marshaller_Address,
        __Marshaller_google_protobuf_Empty);

    static readonly aelf::Method<global::Google.Protobuf.WellKnownTypes.UInt32Value, global::Google.Protobuf.WellKnownTypes.Empty> __Method_Vote = new aelf::Method<global::Google.Protobuf.WellKnownTypes.UInt32Value, global::Google.Protobuf.WellKnownTypes.Empty>(
        aelf::MethodType.Action,
        __ServiceName,
        "Vote",
        __Marshaller_google_protobuf_UInt32Value,
        __Marshaller_google_protobuf_Empty);

    static readonly aelf::Method<global::Google.Protobuf.WellKnownTypes.Empty, global::Ballot.Proposal> __Method_GetWinningProposal = new aelf::Method<global::Google.Protobuf.WellKnownTypes.Empty, global::Ballot.Proposal>(
        aelf::MethodType.View,
        __ServiceName,
        "GetWinningProposal",
        __Marshaller_google_protobuf_Empty,
        __Marshaller_ballot_Proposal);

    static readonly aelf::Method<global::Google.Protobuf.WellKnownTypes.Empty, global::AElf.Common.Address> __Method_GetChainPerson = new aelf::Method<global::Google.Protobuf.WellKnownTypes.Empty, global::AElf.Common.Address>(
        aelf::MethodType.View,
        __ServiceName,
        "GetChainPerson",
        __Marshaller_google_protobuf_Empty,
        __Marshaller_Address);

    #endregion

    #region Descriptors
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Ballot.BallotReflection.Descriptor.Services[0]; }
    }

    public static global::System.Collections.Generic.IReadOnlyList<global::Google.Protobuf.Reflection.ServiceDescriptor> Descriptors
    {
      get
      {
        return new global::System.Collections.Generic.List<global::Google.Protobuf.Reflection.ServiceDescriptor>()
        {
          global::Ballot.BallotReflection.Descriptor.Services[0],
        };
      }
    }
    #endregion

    /// <summary>Base class for the contract of Ballot</summary>
    public abstract partial class BallotBase : AElf.Sdk.CSharp.CSharpSmartContract<BallotState>
    {
      public virtual global::Google.Protobuf.WellKnownTypes.Empty Initialize(global::Ballot.InitializeInput input)
      {
        throw new global::System.NotImplementedException();
      }

      public virtual global::Google.Protobuf.WellKnownTypes.Empty GiveRightToVote(global::AElf.Common.Address input)
      {
        throw new global::System.NotImplementedException();
      }

      public virtual global::Google.Protobuf.WellKnownTypes.Empty Delegate(global::AElf.Common.Address input)
      {
        throw new global::System.NotImplementedException();
      }

      public virtual global::Google.Protobuf.WellKnownTypes.Empty Vote(global::Google.Protobuf.WellKnownTypes.UInt32Value input)
      {
        throw new global::System.NotImplementedException();
      }

      public virtual global::Ballot.Proposal GetWinningProposal(global::Google.Protobuf.WellKnownTypes.Empty input)
      {
        throw new global::System.NotImplementedException();
      }

      public virtual global::AElf.Common.Address GetChainPerson(global::Google.Protobuf.WellKnownTypes.Empty input)
      {
        throw new global::System.NotImplementedException();
      }

    }

    public static aelf::ServerServiceDefinition BindService(BallotBase serviceImpl)
    {
      return aelf::ServerServiceDefinition.CreateBuilder()
          .AddDescriptors(Descriptors)
          .AddMethod(__Method_Initialize, serviceImpl.Initialize)
          .AddMethod(__Method_GiveRightToVote, serviceImpl.GiveRightToVote)
          .AddMethod(__Method_Delegate, serviceImpl.Delegate)
          .AddMethod(__Method_Vote, serviceImpl.Vote)
          .AddMethod(__Method_GetWinningProposal, serviceImpl.GetWinningProposal)
          .AddMethod(__Method_GetChainPerson, serviceImpl.GetChainPerson).Build();
    }

  }
}
#endregion


```

3. Business logics

   Now we already declared the methods and the state of the contract. We only miss the logics of how to query or update the state values. Check the code below for the logics we ported from solidity. You can do a line-by-line comparison with the solidity code. And you can find the logics are almost exactly the same except in aelf we explicitly retrieve and update the state values.
```csharp
using System;
using AElf.Common;
using AElf.Sdk.CSharp;
using Ballot;
using Google.Protobuf.WellKnownTypes;

namespace Ballot
{
    public class Ballot : BallotContainer.BallotBase
    {
        public override Empty Initialize(InitializeInput input)
        {
            Assert(State.ChairPerson.Value == null, "Already intialized.");
            State.ChairPerson.Value = Context.Sender;
            State.Voters[Context.Sender] = new Voter()
            {
                Weight = 1
            };
            var count = State.ProposalCount.Value;
            foreach (var name in input.ProposalNames)
            {
                State.Proposals[count] = new Proposal()
                {
                    Name = name,
                    VoteCount = 0
                };
                count = count.Add(1);
            }

            State.ProposalCount.Value = count;
            return new Empty();
        }

        public override Empty GiveRightToVote(Address input)
        {
            Assert(Context.Sender == State.ChairPerson.Value, "Only chairperson can give right to vote.");
            var voter = State.Voters[input] ?? new Voter();
            Assert(!voter.Voted, "The voter already voted.");
            Assert(voter.Weight == 0);
            voter.Weight = 1;
            State.Voters[input] = voter;
            return new Empty();
        }

        public override Empty Delegate(Address input)
        {
            var to = input;
            var sender = State.Voters[Context.Sender] ?? new Voter();
            Assert(!sender.Voted, "You already voted.");
            Assert(to != Context.Sender, "Self-delegation is disallowed.");
            var voter = State.Voters[to] ?? new Voter();
            while (voter.Delegate != null)
            {
                to = voter.Delegate;
                voter = State.Voters[to] ?? new Voter();
                Assert(to != Context.Sender, "Found loop in delegation.");
            }

            sender.Voted = true;
            sender.Delegate = to;
            State.Voters[Context.Sender] = sender;
            var delegateVoter = State.Voters[to];
            if (delegateVoter.Voted)
            {
                var proposal = State.Proposals[delegateVoter.Vote];
                proposal.VoteCount = proposal.VoteCount.Add(sender.Weight);
            }
            else
            {
                delegateVoter.Weight = delegateVoter.Weight.Add(sender.Weight);
                State.Voters[to] = delegateVoter;
            }

            return new Empty();
        }

        public override Empty Vote(UInt32Value input)
        {
            var proposal = input;
            var sender = State.Voters[Context.Sender] ?? new Voter();
            Assert(sender.Weight != 0, "Has no right to vote.");
            Assert(!sender.Voted, "Already voted.");
            sender.Voted = true;
            sender.Vote = proposal.Value;
            State.Voters[Context.Sender] = sender;
            var proposalRecord = State.Proposals[proposal.Value];
            proposalRecord.VoteCount = proposalRecord.VoteCount.Add(sender.Weight);
            State.Proposals[proposal.Value] = proposalRecord;
            return new Empty();
        }


        public override Proposal GetWinningProposal(Empty input)
        {
            var winningProposal = new Proposal();
            var proposalCount = State.ProposalCount.Value;
            for (uint p = 0; p < proposalCount; p++)
            {
                var proposal = State.Proposals[p];
                if (proposal.VoteCount > winningProposal.VoteCount)
                {
                    winningProposal = proposal;
                }
            }

            return winningProposal;
        }

        public override Address GetChainPerson(Empty input)
        {
            return State.ChairPerson.Value;
        }
    }
}
```